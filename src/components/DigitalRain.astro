---
---

<canvas id="digital-rain"></canvas>

<style>
  #digital-rain {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Changed from -1 to 0 to ensure visibility */
    opacity: 0.8;
    pointer-events: none;
  }
</style>

<script>
  console.log("Digital Rain script initializing...");
  const canvas = document.getElementById('digital-rain') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');

  if (canvas && ctx) {
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Katakana + Latin + Numbers
    const chars = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const charArray = chars.split('');

    const fontSize = 16;
    const columns = width / fontSize;

    // Array of drops - one per column
    const drops: number[] = [];
    for (let x = 0; x < columns; x++) {
      drops[x] = 1;
    }

    // Mouse tracking
    let mouseX = -1000;
    let mouseY = -1000;
    
    window.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const draw = () => {
      // Black BG for the trail effect
      ctx.fillStyle = 'rgba(13, 13, 13, 0.05)';
      ctx.fillRect(0, 0, width, height);

      ctx.font = `${fontSize}px 'Jacquard 12', monospace`;

      for (let i = 0; i < drops.length; i++) {
        const text = charArray[Math.floor(Math.random() * charArray.length)];
        const x = i * fontSize;
        const y = drops[i] * fontSize;

        // Glitch effect logic
        const dx = mouseX - x;
        const dy = mouseY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const isGlitch = distance < 100; // 100px radius

        if (isGlitch) {
            ctx.fillStyle = '#8A2BE2'; // Purple accent
            // Jitter position
            const jitterX = (Math.random() - 0.5) * 5;
            const jitterY = (Math.random() - 0.5) * 5;
            ctx.fillText(text, x + jitterX, y + jitterY);
        } else {
            ctx.fillStyle = '#39ff14'; // Matrix Green
            ctx.fillText(text, x, y);
        }

        // Sending the drop back to the top randomly after it has crossed the screen
        // Adding a randomness to the reset to make the drops scattered on the Y axis
        if (drops[i] * fontSize > height && Math.random() > 0.975) {
          drops[i] = 0;
        }

        // Incrementing Y coordinate
        drops[i]++;
      }
    };

    // Resize handler
    window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        // Re-initialize drops to fit new width
        const newColumns = width / fontSize;
        // Preserve existing drops if possible, or extend
        if (newColumns > drops.length) {
            for (let x = drops.length; x < newColumns; x++) {
                drops[x] = Math.random() * (height / fontSize); // Start at random positions
            }
        }
    });

    setInterval(draw, 33);
  }
</script>


